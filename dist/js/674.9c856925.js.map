{"version":3,"file":"js/674.9c856925.js","mappings":"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","sources":["webpack://zhizhi_cms/../../../packages/components/input/src/utils.ts","webpack://zhizhi_cms/../../../packages/components/input/src/input.ts","webpack://zhizhi_cms/../../../packages/hooks/use-attrs/index.ts","webpack://zhizhi_cms/../../../packages/hooks/use-cursor/index.ts","webpack://zhizhi_cms/../../../packages/utils/i18n.ts","webpack://zhizhi_cms/../../../packages/components/input/src/input.vue","webpack://zhizhi_cms/../../../packages/components/input/index.ts"],"sourcesContent":["import { isNumber } from '@element-plus/utils'\n\nlet hiddenTextarea: HTMLTextAreaElement | undefined = undefined\n\nconst HIDDEN_STYLE = `\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n`\n\nconst CONTEXT_STYLE = [\n  'letter-spacing',\n  'line-height',\n  'padding-top',\n  'padding-bottom',\n  'font-family',\n  'font-weight',\n  'font-size',\n  'text-rendering',\n  'text-transform',\n  'width',\n  'text-indent',\n  'padding-left',\n  'padding-right',\n  'border-width',\n  'box-sizing',\n]\n\ntype NodeStyle = {\n  contextStyle: string\n  boxSizing: string\n  paddingSize: number\n  borderSize: number\n}\n\ntype TextAreaHeight = {\n  height: string\n  minHeight?: string\n}\n\nfunction calculateNodeStyling(targetElement: Element): NodeStyle {\n  const style = window.getComputedStyle(targetElement)\n\n  const boxSizing = style.getPropertyValue('box-sizing')\n\n  const paddingSize =\n    Number.parseFloat(style.getPropertyValue('padding-bottom')) +\n    Number.parseFloat(style.getPropertyValue('padding-top'))\n\n  const borderSize =\n    Number.parseFloat(style.getPropertyValue('border-bottom-width')) +\n    Number.parseFloat(style.getPropertyValue('border-top-width'))\n\n  const contextStyle = CONTEXT_STYLE.map(\n    (name) => `${name}:${style.getPropertyValue(name)}`\n  ).join(';')\n\n  return { contextStyle, paddingSize, borderSize, boxSizing }\n}\n\nexport function calcTextareaHeight(\n  targetElement: HTMLTextAreaElement,\n  minRows = 1,\n  maxRows?: number\n): TextAreaHeight {\n  if (!hiddenTextarea) {\n    hiddenTextarea = document.createElement('textarea')\n    document.body.appendChild(hiddenTextarea)\n  }\n\n  const { paddingSize, borderSize, boxSizing, contextStyle } =\n    calculateNodeStyling(targetElement)\n\n  hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`)\n  hiddenTextarea.value = targetElement.value || targetElement.placeholder || ''\n\n  let height = hiddenTextarea.scrollHeight\n  const result = {} as TextAreaHeight\n\n  if (boxSizing === 'border-box') {\n    height = height + borderSize\n  } else if (boxSizing === 'content-box') {\n    height = height - paddingSize\n  }\n\n  hiddenTextarea.value = ''\n  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize\n\n  if (isNumber(minRows)) {\n    let minHeight = singleRowHeight * minRows\n    if (boxSizing === 'border-box') {\n      minHeight = minHeight + paddingSize + borderSize\n    }\n    height = Math.max(minHeight, height)\n    result.minHeight = `${minHeight}px`\n  }\n  if (isNumber(maxRows)) {\n    let maxHeight = singleRowHeight * maxRows\n    if (boxSizing === 'border-box') {\n      maxHeight = maxHeight + paddingSize + borderSize\n    }\n    height = Math.min(maxHeight, height)\n  }\n  result.height = `${height}px`\n  hiddenTextarea.parentNode?.removeChild(hiddenTextarea)\n  hiddenTextarea = undefined\n\n  return result\n}\n","import { isString } from '@vue/shared'\nimport {\n  buildProps,\n  definePropType,\n  iconPropType,\n  mutable,\n} from '@element-plus/utils'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { useSizeProp } from '@element-plus/hooks'\nimport type Input from './input.vue'\nimport type { ExtractPropTypes, StyleValue } from 'vue'\n\nexport type InputAutoSize = { minRows?: number; maxRows?: number } | boolean\n\nexport const inputProps = buildProps({\n  id: {\n    type: String,\n    default: undefined,\n  },\n  size: useSizeProp,\n  disabled: Boolean,\n  modelValue: {\n    type: definePropType<string | number | null | undefined>([\n      String,\n      Number,\n      Object,\n    ]),\n    default: '',\n  },\n  type: {\n    type: String,\n    default: 'text',\n  },\n  resize: {\n    type: String,\n    values: ['none', 'both', 'horizontal', 'vertical'],\n  },\n  autosize: {\n    type: definePropType<InputAutoSize>([Boolean, Object]),\n    default: false,\n  },\n  autocomplete: {\n    type: String,\n    default: 'off',\n  },\n  formatter: {\n    type: Function,\n  },\n  parser: {\n    type: Function,\n  },\n  placeholder: {\n    type: String,\n  },\n  form: {\n    type: String,\n    default: '',\n  },\n  readonly: {\n    type: Boolean,\n    default: false,\n  },\n  clearable: {\n    type: Boolean,\n    default: false,\n  },\n  showPassword: {\n    type: Boolean,\n    default: false,\n  },\n  showWordLimit: {\n    type: Boolean,\n    default: false,\n  },\n  suffixIcon: {\n    type: iconPropType,\n    default: '',\n  },\n  prefixIcon: {\n    type: iconPropType,\n    default: '',\n  },\n  containerRole: {\n    type: String,\n    default: undefined,\n  },\n  label: {\n    type: String,\n    default: undefined,\n  },\n  tabindex: {\n    type: [String, Number],\n    default: 0,\n  },\n  validateEvent: {\n    type: Boolean,\n    default: true,\n  },\n  inputStyle: {\n    type: definePropType<StyleValue>([Object, Array, String]),\n    default: () => mutable({} as const),\n  },\n} as const)\nexport type InputProps = ExtractPropTypes<typeof inputProps>\n\nexport const inputEmits = {\n  [UPDATE_MODEL_EVENT]: (value: string) => isString(value),\n  input: (value: string) => isString(value),\n  change: (value: string) => isString(value),\n  focus: (evt: FocusEvent) => evt instanceof FocusEvent,\n  blur: (evt: FocusEvent) => evt instanceof FocusEvent,\n  clear: () => true,\n  mouseleave: (evt: MouseEvent) => evt instanceof MouseEvent,\n  mouseenter: (evt: MouseEvent) => evt instanceof MouseEvent,\n  // NOTE: when autofill by browser, the keydown event is instanceof Event, not KeyboardEvent\n  // relative bug report https://github.com/element-plus/element-plus/issues/6665\n  keydown: (evt: KeyboardEvent | Event) => evt instanceof Event,\n  compositionstart: (evt: CompositionEvent) => evt instanceof CompositionEvent,\n  compositionupdate: (evt: CompositionEvent) => evt instanceof CompositionEvent,\n  compositionend: (evt: CompositionEvent) => evt instanceof CompositionEvent,\n}\nexport type InputEmits = typeof inputEmits\n\nexport type InputInstance = InstanceType<typeof Input>\n","import { computed, getCurrentInstance } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { ComputedRef } from 'vue'\n\ninterface Params {\n  excludeListeners?: boolean\n  excludeKeys?: ComputedRef<string[]>\n}\n\nconst DEFAULT_EXCLUDE_KEYS = ['class', 'style']\nconst LISTENER_PREFIX = /^on[A-Z]/\n\nexport const useAttrs = (\n  params: Params = {}\n): ComputedRef<Record<string, unknown>> => {\n  const { excludeListeners = false, excludeKeys } = params\n  const allExcludeKeys = computed<string[]>(() => {\n    return (excludeKeys?.value || []).concat(DEFAULT_EXCLUDE_KEYS)\n  })\n\n  const instance = getCurrentInstance()\n  if (!instance) {\n    debugWarn(\n      'use-attrs',\n      'getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function'\n    )\n    return computed(() => ({}))\n  }\n\n  return computed(() =>\n    fromPairs(\n      Object.entries(instance.proxy?.$attrs!).filter(\n        ([key]) =>\n          !allExcludeKeys.value.includes(key) &&\n          !(excludeListeners && LISTENER_PREFIX.test(key))\n      )\n    )\n  )\n}\n","import { ref } from 'vue'\n\nimport type { ShallowRef } from 'vue'\n\n// Keep input cursor in the correct position when we use formatter.\nexport function useCursor(\n  input: ShallowRef<HTMLInputElement | undefined>\n): [() => void, () => void] {\n  const selectionRef = ref<{\n    selectionStart?: number\n    selectionEnd?: number\n    value?: string\n    beforeTxt?: string\n    afterTxt?: string\n  }>()\n\n  function recordCursor() {\n    if (input.value == undefined) return\n\n    const { selectionStart, selectionEnd, value } = input.value\n\n    if (selectionStart == null || selectionEnd == null) return\n\n    const beforeTxt = value.slice(0, Math.max(0, selectionStart))\n    const afterTxt = value.slice(Math.max(0, selectionEnd))\n\n    selectionRef.value = {\n      selectionStart,\n      selectionEnd,\n      value,\n      beforeTxt,\n      afterTxt,\n    }\n  }\n  function setCursor() {\n    if (input.value == undefined || selectionRef.value == undefined) return\n\n    const { value } = input.value\n    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value\n\n    if (\n      beforeTxt == undefined ||\n      afterTxt == undefined ||\n      selectionStart == undefined\n    )\n      return\n\n    let startPos = value.length\n\n    if (value.endsWith(afterTxt)) {\n      startPos = value.length - afterTxt.length\n    } else if (value.startsWith(beforeTxt)) {\n      startPos = beforeTxt.length\n    } else {\n      const beforeLastChar = beforeTxt[selectionStart - 1]\n      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1)\n      if (newIndex !== -1) {\n        startPos = newIndex + 1\n      }\n    }\n\n    input.value.setSelectionRange(startPos, startPos)\n  }\n\n  return [recordCursor, setCursor]\n}\n","export const isKorean = (text: string) =>\n  /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi.test(text)\n","<template>\n  <div\n    v-show=\"type !== 'hidden'\"\n    v-bind=\"containerAttrs\"\n    :class=\"[\n      type === 'textarea' ? nsTextarea.b() : nsInput.b(),\n      nsInput.m(inputSize),\n      nsInput.is('disabled', inputDisabled),\n      nsInput.is('exceed', inputExceed),\n      {\n        [nsInput.b('group')]: $slots.prepend || $slots.append,\n        [nsInput.bm('group', 'append')]: $slots.append,\n        [nsInput.bm('group', 'prepend')]: $slots.prepend,\n        [nsInput.m('prefix')]: $slots.prefix || prefixIcon,\n        [nsInput.m('suffix')]:\n          $slots.suffix || suffixIcon || clearable || showPassword,\n        [nsInput.bm('suffix', 'password-clear')]: showClear && showPwdVisible,\n      },\n      $attrs.class,\n    ]\"\n    :style=\"containerStyle\"\n    :role=\"containerRole\"\n    @mouseenter=\"handleMouseEnter\"\n    @mouseleave=\"handleMouseLeave\"\n  >\n    <!-- input -->\n    <template v-if=\"type !== 'textarea'\">\n      <!-- prepend slot -->\n      <div v-if=\"$slots.prepend\" :class=\"nsInput.be('group', 'prepend')\">\n        <slot name=\"prepend\" />\n      </div>\n\n      <div :class=\"[nsInput.e('wrapper'), nsInput.is('focus', focused)]\">\n        <!-- prefix slot -->\n        <span v-if=\"$slots.prefix || prefixIcon\" :class=\"nsInput.e('prefix')\">\n          <span :class=\"nsInput.e('prefix-inner')\">\n            <slot name=\"prefix\" />\n            <el-icon v-if=\"prefixIcon\" :class=\"nsInput.e('icon')\">\n              <component :is=\"prefixIcon\" />\n            </el-icon>\n          </span>\n        </span>\n\n        <input\n          :id=\"inputId\"\n          ref=\"input\"\n          :class=\"nsInput.e('inner')\"\n          v-bind=\"attrs\"\n          :type=\"showPassword ? (passwordVisible ? 'text' : 'password') : type\"\n          :disabled=\"inputDisabled\"\n          :formatter=\"formatter\"\n          :parser=\"parser\"\n          :readonly=\"readonly\"\n          :autocomplete=\"autocomplete\"\n          :tabindex=\"tabindex\"\n          :aria-label=\"label\"\n          :placeholder=\"placeholder\"\n          :style=\"inputStyle\"\n          @compositionstart=\"handleCompositionStart\"\n          @compositionupdate=\"handleCompositionUpdate\"\n          @compositionend=\"handleCompositionEnd\"\n          @input=\"handleInput\"\n          @focus=\"handleFocus\"\n          @blur=\"handleBlur\"\n          @change=\"handleChange\"\n          @keydown=\"handleKeydown\"\n        />\n\n        <!-- suffix slot -->\n        <span v-if=\"suffixVisible\" :class=\"nsInput.e('suffix')\">\n          <span :class=\"nsInput.e('suffix-inner')\">\n            <template\n              v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\"\n            >\n              <slot name=\"suffix\" />\n              <el-icon v-if=\"suffixIcon\" :class=\"nsInput.e('icon')\">\n                <component :is=\"suffixIcon\" />\n              </el-icon>\n            </template>\n            <el-icon\n              v-if=\"showClear\"\n              :class=\"[nsInput.e('icon'), nsInput.e('clear')]\"\n              @mousedown.prevent=\"NOOP\"\n              @click=\"clear\"\n            >\n              <circle-close />\n            </el-icon>\n            <el-icon\n              v-if=\"showPwdVisible\"\n              :class=\"[nsInput.e('icon'), nsInput.e('password')]\"\n              @click=\"handlePasswordVisible\"\n            >\n              <component :is=\"passwordIcon\" />\n            </el-icon>\n            <span v-if=\"isWordLimitVisible\" :class=\"nsInput.e('count')\">\n              <span :class=\"nsInput.e('count-inner')\">\n                {{ textLength }} / {{ attrs.maxlength }}\n              </span>\n            </span>\n            <el-icon\n              v-if=\"validateState && validateIcon && needStatusIcon\"\n              :class=\"[\n                nsInput.e('icon'),\n                nsInput.e('validateIcon'),\n                nsInput.is('loading', validateState === 'validating'),\n              ]\"\n            >\n              <component :is=\"validateIcon\" />\n            </el-icon>\n          </span>\n        </span>\n      </div>\n\n      <!-- append slot -->\n      <div v-if=\"$slots.append\" :class=\"nsInput.be('group', 'append')\">\n        <slot name=\"append\" />\n      </div>\n    </template>\n\n    <!-- textarea -->\n    <template v-else>\n      <textarea\n        :id=\"inputId\"\n        ref=\"textarea\"\n        :class=\"nsTextarea.e('inner')\"\n        v-bind=\"attrs\"\n        :tabindex=\"tabindex\"\n        :disabled=\"inputDisabled\"\n        :readonly=\"readonly\"\n        :autocomplete=\"autocomplete\"\n        :style=\"textareaStyle\"\n        :aria-label=\"label\"\n        :placeholder=\"placeholder\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n        @input=\"handleInput\"\n        @focus=\"handleFocus\"\n        @blur=\"handleBlur\"\n        @change=\"handleChange\"\n        @keydown=\"handleKeydown\"\n      />\n      <span\n        v-if=\"isWordLimitVisible\"\n        :style=\"countStyle\"\n        :class=\"nsInput.e('count')\"\n      >\n        {{ textLength }} / {{ attrs.maxlength }}\n      </span>\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  getCurrentInstance,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  shallowRef,\n  toRef,\n  useAttrs as useRawAttrs,\n  useSlots,\n  watch,\n} from 'vue'\nimport { isClient, useResizeObserver } from '@vueuse/core'\nimport { isNil } from 'lodash-unified'\nimport { ElIcon } from '@element-plus/components/icon'\nimport {\n  CircleClose,\n  Hide as IconHide,\n  View as IconView,\n} from '@element-plus/icons-vue'\nimport {\n  NOOP,\n  ValidateComponentsMap,\n  debugWarn,\n  isKorean,\n  isObject,\n} from '@element-plus/utils'\nimport {\n  useAttrs,\n  useCursor,\n  useDisabled,\n  useFormItem,\n  useFormItemInputId,\n  useNamespace,\n  useSize,\n} from '@element-plus/hooks'\nimport { UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport { calcTextareaHeight } from './utils'\nimport { inputEmits, inputProps } from './input'\nimport type { StyleValue } from 'vue'\n\ntype TargetElement = HTMLInputElement | HTMLTextAreaElement\nconst PENDANT_MAP = {\n  suffix: 'append',\n  prefix: 'prepend',\n} as const\n\ndefineOptions({\n  name: 'ElInput',\n  inheritAttrs: false,\n})\nconst props = defineProps(inputProps)\nconst emit = defineEmits(inputEmits)\n\nconst instance = getCurrentInstance()!\nconst rawAttrs = useRawAttrs()\nconst slots = useSlots()\n\nconst containerAttrs = computed(() => {\n  const comboBoxAttrs: Record<string, unknown> = {}\n  if (props.containerRole === 'combobox') {\n    comboBoxAttrs['aria-haspopup'] = rawAttrs['aria-haspopup']\n    comboBoxAttrs['aria-owns'] = rawAttrs['aria-owns']\n    comboBoxAttrs['aria-expanded'] = rawAttrs['aria-expanded']\n  }\n  return comboBoxAttrs\n})\n\nconst attrs = useAttrs({\n  excludeKeys: computed<string[]>(() => {\n    return Object.keys(containerAttrs.value)\n  }),\n})\nconst { form, formItem } = useFormItem()\nconst { inputId } = useFormItemInputId(props, {\n  formItemContext: formItem,\n})\nconst inputSize = useSize()\nconst inputDisabled = useDisabled()\nconst nsInput = useNamespace('input')\nconst nsTextarea = useNamespace('textarea')\n\nconst input = shallowRef<HTMLInputElement>()\nconst textarea = shallowRef<HTMLTextAreaElement>()\n\nconst focused = ref(false)\nconst hovering = ref(false)\nconst isComposing = ref(false)\nconst passwordVisible = ref(false)\nconst countStyle = ref<StyleValue>()\nconst textareaCalcStyle = shallowRef(props.inputStyle)\n\nconst _ref = computed(() => input.value || textarea.value)\n\nconst needStatusIcon = computed(() => form?.statusIcon ?? false)\nconst validateState = computed(() => formItem?.validateState || '')\nconst validateIcon = computed(\n  () => validateState.value && ValidateComponentsMap[validateState.value]\n)\nconst passwordIcon = computed(() =>\n  passwordVisible.value ? IconView : IconHide\n)\nconst containerStyle = computed<StyleValue>(() => [\n  rawAttrs.style as StyleValue,\n  props.inputStyle,\n])\nconst textareaStyle = computed<StyleValue>(() => [\n  props.inputStyle,\n  textareaCalcStyle.value,\n  { resize: props.resize },\n])\nconst nativeInputValue = computed(() =>\n  isNil(props.modelValue) ? '' : String(props.modelValue)\n)\nconst showClear = computed(\n  () =>\n    props.clearable &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !!nativeInputValue.value &&\n    (focused.value || hovering.value)\n)\nconst showPwdVisible = computed(\n  () =>\n    props.showPassword &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !!nativeInputValue.value &&\n    (!!nativeInputValue.value || focused.value)\n)\nconst isWordLimitVisible = computed(\n  () =>\n    props.showWordLimit &&\n    !!attrs.value.maxlength &&\n    (props.type === 'text' || props.type === 'textarea') &&\n    !inputDisabled.value &&\n    !props.readonly &&\n    !props.showPassword\n)\nconst textLength = computed(() => Array.from(nativeInputValue.value).length)\nconst inputExceed = computed(\n  () =>\n    // show exceed style if length of initial value greater then maxlength\n    !!isWordLimitVisible.value &&\n    textLength.value > Number(attrs.value.maxlength)\n)\nconst suffixVisible = computed(\n  () =>\n    !!slots.suffix ||\n    !!props.suffixIcon ||\n    showClear.value ||\n    props.showPassword ||\n    isWordLimitVisible.value ||\n    (!!validateState.value && needStatusIcon.value)\n)\n\nconst [recordCursor, setCursor] = useCursor(input)\n\nuseResizeObserver(textarea, (entries) => {\n  if (!isWordLimitVisible.value || props.resize !== 'both') return\n  const entry = entries[0]\n  const { width } = entry.contentRect\n  countStyle.value = {\n    /** right: 100% - width + padding(15) + right(6) */\n    right: `calc(100% - ${width + 15 + 6}px)`,\n  }\n})\n\nconst resizeTextarea = () => {\n  const { type, autosize } = props\n\n  if (!isClient || type !== 'textarea') return\n\n  if (autosize) {\n    const minRows = isObject(autosize) ? autosize.minRows : undefined\n    const maxRows = isObject(autosize) ? autosize.maxRows : undefined\n    textareaCalcStyle.value = {\n      ...calcTextareaHeight(textarea.value!, minRows, maxRows),\n    }\n  } else {\n    textareaCalcStyle.value = {\n      minHeight: calcTextareaHeight(textarea.value!).minHeight,\n    }\n  }\n}\n\nconst setNativeInputValue = () => {\n  const input = _ref.value\n  if (!input || input.value === nativeInputValue.value) return\n  input.value = nativeInputValue.value\n}\n\nconst calcIconOffset = (place: 'prefix' | 'suffix') => {\n  const { el } = instance.vnode\n  if (!el) return\n  const elList = Array.from(\n    (el as Element).querySelectorAll<HTMLSpanElement>(`.${nsInput.e(place)}`)\n  )\n  const target = elList.find((item) => item.parentNode === el)\n  if (!target) return\n\n  const pendant = PENDANT_MAP[place]\n\n  if (slots[pendant]) {\n    target.style.transform = `translateX(${place === 'suffix' ? '-' : ''}${\n      el.querySelector(`.${nsInput.be('group', pendant)}`).offsetWidth\n    }px)`\n  } else {\n    target.removeAttribute('style')\n  }\n}\n\nconst updateIconOffset = () => {\n  calcIconOffset('prefix')\n  calcIconOffset('suffix')\n}\n\nconst handleInput = async (event: Event) => {\n  recordCursor()\n\n  let { value } = event.target as TargetElement\n\n  if (props.formatter) {\n    value = props.parser ? props.parser(value) : value\n    value = props.formatter(value)\n  }\n\n  // should not emit input during composition\n  // see: https://github.com/ElemeFE/element/issues/10516\n  if (isComposing.value) return\n\n  // hack for https://github.com/ElemeFE/element/issues/8548\n  // should remove the following line when we don't support IE\n  if (value === nativeInputValue.value) return\n\n  emit(UPDATE_MODEL_EVENT, value)\n  emit('input', value)\n\n  // ensure native input value is controlled\n  // see: https://github.com/ElemeFE/element/issues/12850\n  await nextTick()\n  setNativeInputValue()\n  setCursor()\n}\n\nconst handleChange = (event: Event) => {\n  emit('change', (event.target as TargetElement).value)\n}\n\nconst handleCompositionStart = (event: CompositionEvent) => {\n  emit('compositionstart', event)\n  isComposing.value = true\n}\n\nconst handleCompositionUpdate = (event: CompositionEvent) => {\n  emit('compositionupdate', event)\n  const text = (event.target as HTMLInputElement)?.value\n  const lastCharacter = text[text.length - 1] || ''\n  isComposing.value = !isKorean(lastCharacter)\n}\n\nconst handleCompositionEnd = (event: CompositionEvent) => {\n  emit('compositionend', event)\n  if (isComposing.value) {\n    isComposing.value = false\n    handleInput(event)\n  }\n}\n\nconst handlePasswordVisible = () => {\n  passwordVisible.value = !passwordVisible.value\n  focus()\n}\n\nconst focus = async () => {\n  // see: https://github.com/ElemeFE/element/issues/18573\n  await nextTick()\n  _ref.value?.focus()\n}\n\nconst blur = () => _ref.value?.blur()\n\nconst handleFocus = (event: FocusEvent) => {\n  focused.value = true\n  emit('focus', event)\n}\n\nconst handleBlur = (event: FocusEvent) => {\n  focused.value = false\n  emit('blur', event)\n  if (props.validateEvent) {\n    formItem?.validate?.('blur').catch((err) => debugWarn(err))\n  }\n}\n\nconst handleMouseLeave = (evt: MouseEvent) => {\n  hovering.value = false\n  emit('mouseleave', evt)\n}\n\nconst handleMouseEnter = (evt: MouseEvent) => {\n  hovering.value = true\n  emit('mouseenter', evt)\n}\n\nconst handleKeydown = (evt: KeyboardEvent) => {\n  emit('keydown', evt)\n}\n\nconst select = () => {\n  _ref.value?.select()\n}\n\nconst clear = () => {\n  emit(UPDATE_MODEL_EVENT, '')\n  emit('change', '')\n  emit('clear')\n  emit('input', '')\n}\n\nwatch(\n  () => props.modelValue,\n  () => {\n    nextTick(() => resizeTextarea())\n    if (props.validateEvent) {\n      formItem?.validate?.('change').catch((err) => debugWarn(err))\n    }\n  }\n)\n\n// native input value is set explicitly\n// do not use v-model / :value in template\n// see: https://github.com/ElemeFE/element/issues/14521\nwatch(nativeInputValue, () => setNativeInputValue())\n\n// when change between <input> and <textarea>,\n// update DOM dependent value and styles\n// https://github.com/ElemeFE/element/issues/14857\nwatch(\n  () => props.type,\n  async () => {\n    await nextTick()\n    setNativeInputValue()\n    resizeTextarea()\n    updateIconOffset()\n  }\n)\n\nonMounted(async () => {\n  if (!props.formatter && props.parser) {\n    debugWarn(\n      'ElInput',\n      'If you set the parser, you also need to set the formatter.'\n    )\n  }\n  setNativeInputValue()\n  updateIconOffset()\n  await nextTick()\n  resizeTextarea()\n})\n\nonUpdated(async () => {\n  await nextTick()\n  updateIconOffset()\n})\n\ndefineExpose({\n  /** @description HTML input element */\n  input,\n  /** @description HTML textarea element */\n  textarea,\n  /** @description HTML element, input or textarea */\n  ref: _ref,\n  /** @description style of textarea. */\n  textareaStyle,\n\n  /** @description from props (used on unit test) */\n  autosize: toRef(props, 'autosize'),\n\n  /** @description HTML input element native method */\n  focus,\n  /** @description HTML input element native method */\n  blur,\n  /** @description HTML input element native method */\n  select,\n  /** @description clear input value */\n  clear,\n  /** @description resize textarea. */\n  resizeTextarea,\n})\n</script>\n","import { withInstall } from '@element-plus/utils'\n\nimport Input from './src/input.vue'\n\nexport const ElInput = withInstall(Input)\nexport default ElInput\n\nexport * from './src/input'\n"],"names":["hiddenTextarea","HIDDEN_STYLE","CONTEXT_STYLE","calculateNodeStyling","targetElement","style","window","getComputedStyle","boxSizing","getPropertyValue","paddingSize","Number","parseFloat","borderSize","contextStyle","map","name","join","calcTextareaHeight","minRows","maxRows","_a","document","createElement","body","appendChild","setAttribute","value","placeholder","height","scrollHeight","result","singleRowHeight","isNumber","minHeight","Math","max","maxHeight","min","parentNode","removeChild","inputProps","buildProps","id","type","String","default","size","useSizeProp","disabled","Boolean","modelValue","definePropType","Object","resize","values","autosize","autocomplete","formatter","Function","parser","form","readonly","clearable","showPassword","showWordLimit","suffixIcon","iconPropType","prefixIcon","containerRole","label","tabindex","validateEvent","inputStyle","Array","mutable","inputEmits","UPDATE_MODEL_EVENT","isString","input","change","focus","evt","FocusEvent","blur","clear","mouseleave","MouseEvent","mouseenter","keydown","Event","compositionstart","CompositionEvent","compositionupdate","compositionend","DEFAULT_EXCLUDE_KEYS","LISTENER_PREFIX","useAttrs","params","excludeListeners","excludeKeys","allExcludeKeys","computed","concat","instance","getCurrentInstance","fromPairs","entries","proxy","$attrs","filter","key","includes","test","debugWarn","useCursor","selectionRef","ref","recordCursor","selectionStart","selectionEnd","beforeTxt","slice","afterTxt","setCursor","startPos","length","endsWith","startsWith","beforeLastChar","newIndex","indexOf","setSelectionRange","isKorean","text","PENDANT_MAP","suffix","prefix","rawAttrs","slots","containerAttrs","comboBoxAttrs","attrs","formItem","inputId","formItemContext","inputSize","inputDisabled","nsInput","nsTextarea","textarea","focused","hovering","isComposing","passwordVisible","countStyle","textareaCalcStyle","props","_ref","needStatusIcon","validateIcon","passwordIcon","useResizeObserver","width","right","input2","el","target","calcIconOffset","emit","setNativeInputValue","handleInput","watch","nextTick","resizeTextarea","updateIconOffset","onMounted","onUpdated","expose","ElInput","withInstall","Input"],"sourceRoot":""}